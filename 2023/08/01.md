## 取り組んだ課題一覧
- JavaScript I 
- JavaScript II
- JavaScript III
- JavaScript IV
## わかったこと
- console.log("文字列")で出力
- 文字列は""または''で囲む
- //でコメントアウト
- 文末は;を入れる
- let 変数名 = 値 で変数を定義する
- const 定数名 =値で定数を定義する
- テンプレートリテラルという、文字列のなかに変数や定数を埋め込むことができる
- `${変数名}を埋め込む`のように書く、この時、文字列全体をバックコーテーション(``)で囲む
- 数値と文字列を区別する厳密等価演算子がある、特に理由がなければこちらを使う
- xxx === 12,xxx !== "12"
- 繰り返し処理はwhileを使う
- 配列は[]で囲む、定数や変数に代入可能
- 配列を定数に代入していても要素の更新はできる
- 配列.lengthで要素数を取得できる
- オブジェクトは配列に近いものでそれぞれの要素にプロパティという名付けを行って要素を管理できる
- {プロパティA:要素A,プロパティB:要素B}
- オブジェクトの値を取得するときはオブジェクト.プロパティで取得、値の上書きもできる
- オブジェクトを要素に持つ配列を作ることができる
- objects[1]←配列の要素であるオブジェクトを取得、objects[1].name←オブジェクトの要素を取得
- 要素がないときなど、値が存在しないときundefindと表示される
- オブジェクトはさらにオブジェクトを要素に持つことができる
- 関数は定数(や変数)のなかに定義する、function()を使う
- const 定数名=function(){処理}
- 呼び出すときは定数名();
- 定義するとき、function()ではなく()=>とシンプルに書くことができる、これをアロー関数という
- 引数は (引数名)=> と書く
- 関数はreturnで戻り値を返す、関数の記述がそのまま戻り値となる
- returnは関数の処理を終了させる機能も持つ、それ以降の記述は到達できない
- 関数の内外で同じ名前で定義した変数は別々のものとして扱う
- オブジェクトの値には関数を使うこともできる
- オブジェクトの関数を呼び出すときは定数名.プロパティ名()
- コンストラクタはインスタンスを生成するときに実行したい処理や設定を追加するための機能
- constructor(){ } と記述する
- コンストラクタはインスタンスごとに毎回実行される
- コンストラクタのなかで this.プロパティ名 = 値 とする生成されたインスタンスにプロパティと値を追加できる
- コンストラクタの中で追加した値はオブジェクトと同様に インスタンス.プロパティ名 とすることでクラスの外で使用できる
- コンストラクタに引数を追加できる、コンストラクタに引数を追加するには new クラス名(引数) とする
- メソッドはインスタンスの動作のようなものでクラスの処理を定義できる
- メソッド名() {処理} で定義する
- 呼び出すときはインスタンス.メソッド名()
- class 新クラス名 extends 継承元クラス名 { } で継承
- 子クラスで定義した独自のメソッドは、親クラスから呼び出すことはできない
- コンストラクタもオーバーライドできる
- 子クラスにプロパティを追加したいときなどにもちいる
- コンストラクタにオーバーライドするときは1行目にsuper();と記述する
- super()の部分では親クラスのコンストラクタを呼び出しているので、親クラスのコンストラクタが引数を受け取る場合はsuper(引数)とする
## 次やること
- JavaScript V
## 感じたこと
- 基本的にJavaScriptはC#と同じで馴染みやすい
- 一部記述方法が違うので、その点に注意が必要
## 学習時間
- Today:4.5h Total:45h
